% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cutpointr.R
\name{cutpointr}
\alias{cutpointr}
\title{Determine and evaluate optimal cutpoints.}
\usage{
cutpointr(data, x, class, subgroup, pos_class = NULL, neg_class = NULL,
  direction = NULL, method = maximize_metric, boot_runs = 0,
  metric = youden, use_midpoints = FALSE, na.rm = FALSE,
  allowParallel = FALSE, ...)
}
\arguments{
\item{data}{A data frame or tibble in which the columns that are given in x, class and possibly subgroup can be found}

\item{x}{The variable name (with or without quotation marks) to be used for classification, e.g. predictions or test values.}

\item{class}{The variable name (with or without quotation marks) indicating class membership.}

\item{subgroup}{The variable name of an additional covariate that identifies subgroups. Separate
optimal cutpoints will be determined by group. Numeric, character and factor are
allowed. Also expressions like z > 10 are possible.}

\item{pos_class}{(optional) The value of class that indicates the positive class}

\item{neg_class}{(optional) The value of class that indicates the negative class}

\item{direction}{(character, optional) Use ">" or "<" to indicate whether x
is supposed to be larger or smaller for the positive class.}

\item{boot_runs}{(numeric, optional) If positive, this number of bootstrap samples
will be used to assess the variability and the out-of-sample performance.}

\item{use_midpoints}{(logical) If TRUE (default FALSE) the returned optimal
cutpoint will be the mean of the optimal cutpoint and the next highest
observation (for direction = ">") or the next lowest observation
(for direction = "<").}

\item{na.rm}{(logical) Set to TRUE (default FALSE) to keep only complete
cases of x, class and subgroup (if specified). Missing values with
na.rm = FALSE will raise an error.}

\item{allowParallel}{(logical) If TRUE, the bootstrapping will be parallelized
using foreach. A local cluster, for example, should have been started manually
beforehand.}

\item{...}{Further optional arguments that will be passed to optcut_func.}

\item{optcut_func}{(function or character) A function for determining cutpoints. Can
be user supplied or use some of the built in methods. See details.}

\item{boot_metric_func}{(function) The function to compute a metric using the
out-of-bag values during bootstrapping. A way of validating the performance.
User defined functions can be supplied, see details.}
}
\description{
Using predictions (e.g. test values) and binary class labels, this function
will determine "optimal" cutpoints using various selectable methods. The
methods for cutpoint determination can be evaluated using bootstrapping. An
estimate of the cutpoint variability and the out-of-sample performance will
be returned.
}
\details{
If direction and/or pos_class and neg_class are not given, the function will
assume that higher values indicate the positive class and assign the class
with a higher mean as the positive class.

Different methods can be used for determining the "optimal" cutpoint via
the optcut_func argument. The package includes the following cutpoint functions:
\itemize{
 \item oc_youden: Youden- or J-Index, maximize sensitivity + specificity - 1
 \item oc_equalsesp: minimize the absolute difference of sensitivity and specificity
 \item oc_OptimalCutpoints: A wrapper for optimal.cutpoints from the OptimalCutpoints package.
 Supply an additional "methods" argument with the method choice corresponding
 to a method from the OptimalCutpoints package
}

User defined functions can be supplied to optcut_func, too. As a reference,
the code of all included cutpoint functions can be accessed by simply typing
their name. To define a new cutpoint function, create a function that may take
as input(s):
\itemize{
 \item data
 \item x
 \item class
 \item pos_class
 \item neg_class
 \item direction
}

The ... argument can be used to avoid an error if not all of the above
arguments are needed. The function should return a data frame or tbl_df with
one row, the column "optimal_cutpoint, and a column with an arbitraty name
with the metric value at the optimal cutpoint.

If boot_runs is positive, that number of bootstrap samples will be drawn
and the optimal cutpoint using optcut_func will be determined. Additionally,
as an alternative to cross validation, boot_metric_func will be used to
score the out-of-bag predictions using the cutpoints determined by
optcut_func. By default, out-of-bag accuracy will be assessed. Accuracy,
Sensitivity, Specificity, Kappa, true positives/negatives and false
positives/negatives are always included in the bootstrap results.
User defined functions can be used as well which can accept the following
inputs:
\itemize{
 \item tp
 \item fp
 \item tn
 \item fn
}

If not all inputs are needed ... can be used to avoid an unused argument error.

If multiple optimal cutpoints are found, the first one is returned and a
warning including all optimal cutpoints is issued. The first one refers to
the minimum of the optimal cutpoints if direction = ">" or to the maximum
of the optimal cutpoints if direction = "<".

If use_midpoints is set to TRUE and multiple optimal cutpoints are found,
the midpoint of the minimum / maximum of the optimal cutpoints, as described
above, and the next highest / lowest observation is returned. Thus, finding
multiple optimal cutpoints has no effect on determining the midpoint.
}
\examples{
library(cutpointr)
library(OptimalCutpoints)
data(elas)

## Optimal cutpoint for elas
opt_cut <- cutpointr(elas, elas, status)
opt_cut
plot(opt_cut)

opt_cut <- cutpointr(elas, elas, status, direction = "<=", pos_class = 0,
                     method = maximize_metric, metric = youden)
opt_cut
plot(opt_cut)

## Optimal cutpoint for elas, as before, but for the separate subgroups
opt_cut <- cutpointr(elas, elas, status, gender)
opt_cut
plot(opt_cut)

## Bootstrapping to assess cutpoint variability and out-of-sample performance
set.seed(123)
opt_cut <- cutpointr(elas, elas, status, boot_runs = 200)
opt_cut
plot(opt_cut)

## Bootstrapping also works on individual subgroups
set.seed(123)
opt_cut <- cutpointr(elas, elas, status, gender, boot_runs = 200)
opt_cut
plot(opt_cut)

## Transforming variables (unrealistic, just to show the functionality)
set.seed(123)
opt_cut <- cutpointr(elas, log(elas), status == 1,
    gender == "Male" & elas \%\% 1 == 0, boot_runs = 200)
opt_cut
plot(opt_cut)

## Different cutpoint function / metric
set.seed(123)
opt_cut <- cutpointr(elas, elas, status, gender, pos_class = 1, boot_runs = 200,
                     optcut_func = oc_equalsesp)
opt_cut
plot(opt_cut)

## With NAs
elas_na <- elas
elas_na$elas[10] <- NA
elas_na$status[20] <- NA
elas_na$gender[30] <- NA
opt_cut_na <- cutpointr(elas_na, elas, status, gender, na.rm = TRUE)
opt_cut_na
plot(opt_cut_na)

## Parallelized bootstrapping
library(doSNOW)
cl <- makeCluster(2) # 2 cores
registerDoSNOW(cl)
library(doRNG)
registerDoRNG(123) # Reproducible parallel loops using doRNG
opt_cut <- cutpointr(elas, elas, status, gender, pos_class = 1,
               boot_runs = 2000, allowParallel = TRUE)
opt_cut
plot(opt_cut)


## Wrapper for optimal.cutpoints
registerDoRNG(123) # Reproducible parallel loops using doRNG
opt_cut <- cutpointr(elas, elas, status, gender, pos_class = 1, boot_runs = 2000,
                     optcut_func = oc_OptimalCutpoints, methods = "Youden",
                     allowParallel = TRUE)
opt_cut
plot(opt_cut)


}

